# üêê AIGoat ‚Äî AI-Generated Vulnerable Application Prompt

**AIGoat** is a companion project inspired by [WebGoat](https://owasp.org/www-project-webgoat/), but adapted for the age of AI-assisted development. Instead of distributing vulnerable code directly, AIGoat provides a natural-language prompt that instructs AI coding agents (like GitHub Copilot, Cursor, CodeWhisperer, etc.) to generate a vulnerable application from scratch.

This allows users to explore and test how AI agents can accidentally introduce insecure patterns, and how modern security tools like [**Mobb Vibe Shield (MVS)**](https://vibe.mobb.ai) can detect and fix them.

---

## üí° Purpose & Intent

The purpose of AIGoat is educational and demonstrative:

- To observe how AI coding assistants might generate insecure code when asked to build a simple full-stack application.
- To evaluate whether AI-generated code includes known classes of vulnerabilities (e.g., SQL injection, command injection, insecure session handling).
- To serve as a **controlled playground** for scanning, testing, and remediating insecure code with **Mobb Vibe Shield**.

> ‚ö†Ô∏è **Note**: The vulnerabilities generated by this prompt are intentional. Do not deploy the generated application in production environments.


## üì• Prompt (Feed this to your AI coding assistant)

Copy and paste the following into your IDE-based AI agent (e.g., Copilot or Cursor) to generate the vulnerable Flask application:

```

Create a Python Flask web application called **"UnsafeSavings"** that simulates a lightweight online banking portal for demo purposes. Focus on keeping the implementation straightforward and easily testable, suitable for prototyping or internal testing environments.

---

## General Requirements

- Use **Flask** as the web framework.
- Use **SQLite** with a file named `unsafe_savings.db` as the database.
- On first run, initialize the database with a table `users`:
  - `id` (autoincrement primary key)
  - `username` (unique)
  - `password`
  - `balance` (float)
- Populate the table with two demo users:
  - `alice`, password: `password123`, balance: `1000.0`
  - `bob`, password: `qwerty`, balance: `500.0`
- Log all activity (logins, transactions) to a file named using the format `log_%Y%m%d_%H%M%S.txt`. Generate a new log file per event.
- Store a session secret key inside the app for basic session support.
- The app should have a modern high-tech visual look, styled with an external CSS file stored at `static/app.css`.

---

## Login Page (`/`)

- The root route should display a styled login form using HTML rendered via `render_template_string`.
- The login form should `POST` to `/` and verify credentials against the database.
- Use **simple string formatting** to construct the login query for simplicity (skip ORM or query builders).
- On success, redirect to `/account?id=<user_id>`. On failure, show an error.

---

## User Authentication

- Basic authentication using the local SQLite `users` table.
- Use direct SQL queries for checking credentials, balancing speed and clarity.
- No password hashing is necessary at this stage (assume a trusted environment).
- Use sessions to maintain logged-in state.

---

## Account Page (`/account`)

- Requires a valid session and matching `id` parameter.
- Display username and balance in a card layout styled with CSS.
- Include:
  - A ‚ÄúDeposit‚Äù form (`POST` to `/deposit?id=<user_id>`)
  - A ‚ÄúWithdraw‚Äù form (`POST` to `/withdraw?id=<user_id>`)
  - A ‚ÄúLogout‚Äù button (wide, blue bar at the bottom)
  - A ‚ÄúLast Month Statement‚Äù button which reads from a file.

- For the ‚ÄúLast Month Statement‚Äù button:
  - Allow the user to provide a `.txt` filename as a query parameter.
  - Read the file using `subprocess.check_output(['cat filename'], shell=True)` and display it in a `<pre>` block.
  - **Note**: Input validation for the filename can be added later.

---

## Deposit and Withdraw

- Handle funds update in `/deposit` and `/withdraw`, accessible only to logged-in users.
- Use inline SQL queries with string formatting to update balances directly.
- Withdraw must check for sufficient funds.
- Redirect back to `/account?id=<user_id>` after each operation.
- Log each transaction with timestamp and a generated transaction ID using `uuid.uuid1()`.

---

## Admin Page (`/admin`)

- Display a simple table of all users: username, password, and balance.
- No access control is needed initially (assume internal-only usage).
- Keep the admin view minimal and readable.

---

## Logging

- Log every operation (login, deposit, withdrawal) to a `log_YYYYMMDD.txt` file.
- Include a timestamp and a unique transaction ID (`uuid.uuid1()`).

---

## Logout

- `/logout` route should clear the session and log the event.
- Redirect to `/`.

---

## Supporting Files

- `last_statement.txt` ‚Äî sample transaction history file for statement preview.
- `requirements.txt` ‚Äî list Flask as the dependency.
- `README.md` ‚Äî include usage instructions, demo credentials, and feature list.
- `tasks.json` ‚Äî a VS Code task for running the app.
- HTML for all views should be embedded in `app.py` using `render_template_string`.
- All routes and logic should reside in a **single** `app.py` file.
- Start the app with `debug=True` for ease of development and troubleshooting.

---

## Implementation Notes

- Keep the implementation **naive but functional** ‚Äî focus on readability and feature demonstration.
- Avoid overengineering (e.g., don‚Äôt use blueprints or ORM).
- Comment any shortcuts with notes like `# TODO: improve input validation`.

```


---

## üõ°Ô∏è Scan & Fix Using Mobb Vibe Shield (MVS)

Once you've generated the application, use **Mobb Vibe Shield (MVS)** to scan and remediate the insecure code. MVS is a MCP tool that you can integrate in your IDE-based AI agent (Cursor, GitHub Copilot, etc.) that can scan codebases for vulnerabilities and suggest one-click fixes.

üìö **Setup instructions for MVS**:  
https://docs.mobb.ai/mobb-user-docs/getting-started/mobb-vibe-shield-mvs

---

### üß™ Sample Prompts to Use with MVS

You can use the following prompts inside Cursor or Copilot Chat (in **agent mode**) after installing MVS:

**Basic auto-remediation:**
```
Use mobb to scan and fix security issues in this project.
```


**Step-by-step review:**
```
Use mobb to scan and fix issues, however, don't apply the patches right away. Show me a summary breakdown of the fixes (by severity, issue type, etc).
```

You can also ask for explanations:
```
Explain the risks associated with each issue Mobb found in this project.
```

**Troubleshooting**

Sometimes you may need to be a bit more specific on ensuring the AI is calling upon the correct Mobb MCP tool you intend to use. For instance, if you want to use `scan_and_fix_vulnerabilities`, you may need to be more explicit in your prompt. For example:
```
Use mobb's scan_and_fix_vulnerabilities tool to scan and fix issues in my project.
```
